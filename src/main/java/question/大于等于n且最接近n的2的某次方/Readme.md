# 大于等于n且最接近n,2的某次方

给定一个非负整数num，

如何不用循环语句，

返回>=num，并且离num最近的，2的某次方

## 例子

* 7 最接近的时8 0000 0111 最接近 0000 1000

* 13 最接近 16 0000 10101 最接近 0001 0000

## 方案0

count = 0; 原数字 除以 2 结果不为0 ,count++ 最接近的数字为Pow(2,count);

使用了循环,不合题意

## 方案1

原数字 += 原数字提取最右侧的1的数字

直到提取的最右侧的1与自己相等结束

使用了循环,不合题意

## 方案2

如果n是2的某次方,直接返回,否则,提取n最左侧的1,非符号位,返回 提取数 * 2;

n--;保证n不是2的某次方.1除外.假设n的最左侧的1在x位上

PS:  >>> 逻辑右移,高位始终补0

n|=n >>> 1 包括x位往右的2位均变成1

n|=n >>> 2 包括x位往右的4位均变成1

n|=n >>> 4 包括x位往右的8位均变成1

n|=n >>> 8 包括x位往右的16位均变成1

n|=n >>> 16 包括x位往右的32位均变成1

如果n之前是0,n--后,成为负数,按位或之后,仍旧是负数,所以返回1,否则,返回n+1即可
return (n < 0) ? 1 : n + 1;






